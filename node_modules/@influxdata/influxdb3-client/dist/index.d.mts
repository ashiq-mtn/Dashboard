/** IllegalArgumentError is thrown when illegal argument is supplied. */
declare class IllegalArgumentError extends Error {
    constructor(message: string);
}
/**
 * A general HTTP error.
 */
declare class HttpError extends Error {
    readonly statusCode: number;
    readonly statusMessage: string | undefined;
    readonly body?: string | undefined;
    readonly contentType?: string | null | undefined;
    /** application error code, when available */
    code: string | undefined;
    /** json error response */
    json: any;
    constructor(statusCode: number, statusMessage: string | undefined, body?: string | undefined, contentType?: string | null | undefined, message?: string);
}
/** RequestTimedOutError indicates request timeout in the communication with the server */
declare class RequestTimedOutError extends Error {
    constructor();
}
/** AbortError indicates that the communication with the server was aborted */
declare class AbortError extends Error {
    constructor();
}

/**
 * ChunkCombiner is a simplified platform-neutral manipulation of Uint8arrays
 * that allows to process text data on the fly. The implementation can be optimized
 * for the target platform (node vs browser).
 */
interface ChunkCombiner {
    /**
     * Concatenates first and second chunk.
     * @param first - first chunk
     * @param second - second chunk
     * @returns first + second
     */
    concat(first: Uint8Array, second: Uint8Array): Uint8Array;
    /**
     * Converts chunk into a string.
     * @param chunk - chunk
     * @param start - start index
     * @param end - end index
     * @returns string representation of chunk slice
     */
    toUtf8String(chunk: Uint8Array, start: number, end: number): string;
    /**
     * Creates a new chunk from the supplied chunk.
     * @param chunk - chunk to copy
     * @param start - start index
     * @param end - end index
     * @returns a copy of a chunk slice
     */
    copy(chunk: Uint8Array, start: number, end: number): Uint8Array;
}
/**
 * Creates a chunk combiner instance that uses UTF-8
 * TextDecoder to decode Uint8Arrays into strings.
 */
declare function createTextDecoderCombiner(): ChunkCombiner;

/**
 * Allows to cancel a running execution.
 */
interface Cancellable {
    /**
     * Cancels execution.
     */
    cancel(): void;
    isCancelled(): boolean;
}

/**
 * Type of HTTP headers.
 */
type HttpHeaders = {
    [header: string]: string | string[] | undefined;
};

/**
 * Informs about a start of response processing.
 * @param headers - response HTTP headers
 * @param statusCode - response status code
 */
type ResponseStartedFn = (headers: HttpHeaders, statusCode?: number) => void;
/**
 * Observes communication with the server.
 */
interface CommunicationObserver<T> {
    /**
     * Data chunk received, can be called multiple times.
     * @param data - data
     * @returns when `false` value is returned and {@link CommunicationObserver.useResume} is defined,
     * future calls to `next` are paused until resume is called.
     */
    next(data: T): void | boolean;
    /**
     * Communication ended with an error.
     */
    error(error: Error): void;
    /**
     * Communication was successful.
     */
    complete(): void;
    /**
     * Informs about a start of response processing.
     */
    responseStarted?: ResponseStartedFn;
    /**
     * Setups cancelllable for this communication.
     */
    useCancellable?: (cancellable: Cancellable) => void;
    /**
     * Setups a callback that resumes reading of next data, it is called whenever
     * {@link CommunicationObserver.next} returns `false`.
     *
     * @param resume - a function that will resume reading of next data when called
     */
    useResume?: (resume: () => void) => void;
}

/**
 * Options for sending a request message.
 */
interface SendOptions {
    /** HTTP method (POST, PUT, GET, PATCH ...) */
    method: string;
    /** Request HTTP headers. */
    headers?: {
        [key: string]: string;
    };
    /** When specified, message body larger than the treshold is gzipped  */
    gzipThreshold?: number;
    /** Abort signal */
    signal?: AbortSignal;
}
/**
 * Simpified platform-neutral transport layer for communication with InfluxDB.
 */
interface Transport {
    /**
     * Send data to the server and receive communication events via callbacks.
     *
     * @param path - HTTP request path
     * @param requestBody - HTTP request body
     * @param options  - send options
     * @param callbacks - communication callbacks to received data in Uint8Array
     */
    send(path: string, requestBody: string, options: SendOptions, callbacks?: Partial<CommunicationObserver<Uint8Array>>): void;
    /**
     * Sends data to the server and receives decoded result. The type of the result depends on
     * response's content-type (deserialized json, text).
  
     * @param path - HTTP request path
     * @param requestBody - request body
     * @param options - send options
     * @returns response data
     */
    request(path: string, requestBody: any, options: SendOptions, responseStarted?: ResponseStartedFn): Promise<any>;
    /**
     * Sends requestBody and returns response chunks in an async iterable
     * that can be easily consumed in an `for-await` loop.
     *
     * @param path - HTTP request path
     * @param requestBody - request body
     * @param options - send options
     * @returns async iterable
     */
    iterate(path: string, requestBody: any, options: SendOptions): AsyncIterableIterator<Uint8Array>;
}

/**
 * Option for the communication with InfluxDB server.
 */
interface ConnectionOptions {
    /** base host URL */
    host: string;
    /** authentication token */
    token?: string;
    /**
     * socket timeout, 10000 milliseconds by default in node.js
     * @defaultValue 10000
     */
    timeout?: number;
    /**
     * default database for write query if not present as argument.
     */
    database?: string;
    /**
     * TransportOptions supply extra options for the transport layer, they differ between node.js and browser/deno.
     * Node.js transport accepts options specified in {@link https://nodejs.org/api/http.html#http_http_request_options_callback | http.request } or
     * {@link https://nodejs.org/api/https.html#https_https_request_options_callback | https.request }. For example, an `agent` property can be set to
     * {@link https://www.npmjs.com/package/proxy-http-agent | setup HTTP/HTTPS proxy }, {@link  https://nodejs.org/api/tls.html#tls_tls_connect_options_callback | rejectUnauthorized }
     * property can disable TLS server certificate verification. Additionally,
     * {@link https://github.com/follow-redirects/follow-redirects | follow-redirects } property can be also specified
     * in order to follow redirects in node.js.
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/fetch | fetch } is used under the hood in browser/deno.
     * For example,
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/fetch | redirect } property can be set to 'error' to abort request if a redirect occurs.
     */
    transportOptions?: {
        [key: string]: any;
    };
    /**
     * Default HTTP headers to send with every request.
     */
    headers?: Record<string, string>;
    /**
     * Full HTTP web proxy URL including schema, for example http://your-proxy:8080.
     */
    proxyUrl?: string;
}
/** default connection options */
declare const DEFAULT_ConnectionOptions: Partial<ConnectionOptions>;
/**
 * Options used by {@link InfluxDBClient.write} .
 */
interface WriteOptions {
    /** Precision to use in writes for timestamp. default ns */
    precision: WritePrecision;
    /** HTTP headers that will be sent with every write request */
    headers?: {
        [key: string]: string;
    };
    /** When specified, write bodies larger than the threshold are gzipped  */
    gzipThreshold?: number;
    /** InfluxDB Enterprise write consistency as explained in https://docs.influxdata.com/enterprise_influxdb/v1.9/concepts/clustering/#write-consistency */
    consistency?: 'any' | 'one' | 'quorum' | 'all';
}
/** default writeOptions */
declare const DEFAULT_WriteOptions: WriteOptions;
type QueryType = 'sql' | 'influxql';
/**
 * Options used by {@link InfluxDBClient} .
 */
interface ClientOptions extends ConnectionOptions {
    /** supplies and overrides default writing options */
    writeOptions?: Partial<WriteOptions>;
    /** specifies custom transport */
    transport?: Transport;
}
/**
 * Timestamp precision used in write operations.
 * See {@link https://docs.influxdata.com/influxdb/latest/api/#operation/PostWrite }
 */
type WritePrecision = 'ns' | 'us' | 'ms' | 's';

/**
 * Logging interface.
 */
interface Logger {
    error(message: string, err?: any): void;
    warn(message: string, err?: any): void;
}
/**
 * Logger that logs to console.out
 */
declare const consoleLogger: Logger;
declare const Log: Logger;
/**
 * Sets custom logger.
 * @param logger - logger to use
 * @returns previous logger
 */
declare function setLogger(logger: Logger): Logger;

/**
 * Provides functions escape specific parts in InfluxDB line protocol.
 */
declare const escape: {
    /**
     * Measurement escapes measurement names.
     */
    measurement: (value: string) => string;
    /**
     * Quoted escapes quoted values, such as database names.
     */
    quoted: (value: string) => string;
    /**
     * TagEscaper escapes tag keys, tag values, and field keys.
     */
    tag: (value: string) => string;
};

declare function useProcessHrtime(use: boolean): boolean;
/**
 * Exposes functions that creates strings that represent a timestamp that
 * can be used in the line protocol. Micro and nano timestamps are emulated
 * depending on the js platform in use.
 */
declare const currentTime: {
    s: () => string;
    ms: () => string;
    us: () => string;
    ns: () => string;
    seconds: () => string;
    millis: () => string;
    micros: () => string;
    nanos: () => string;
};
/**
 * dateToProtocolTimestamp provides converters for JavaScript Date to InfluxDB Write Protocol Timestamp. Keys are supported precisions.
 */
declare const dateToProtocolTimestamp: {
    s: (d: Date) => string;
    ms: (d: Date) => string;
    us: (d: Date) => string;
    ns: (d: Date) => string;
};
/**
 * convertTimeToNanos converts Point's timestamp to a string.
 * @param value - supported timestamp value
 * @returns line protocol value
 */
declare function convertTimeToNanos(value: string | number | Date | undefined): string | undefined;
declare const convertTime: (value: string | number | Date | undefined, precision?: WritePrecision) => string | undefined;

interface TimeConverter {
    (value: string | number | Date | undefined): string | undefined;
}

type PointRecord = {
    measurement: string;
    fields: Record<string, number | string>;
    tags?: Record<string, string>;
    timestamp?: string | number | Date;
};
/**
 * Point defines values of a single measurement.
 */
declare class Point {
    private _name;
    private _tags;
    private _time;
    /** escaped field values */
    fields: {
        [key: string]: string;
    };
    /**
     * Create a new Point with specified a measurement name.
     *
     * @param measurementName - the measurement name
     */
    constructor(measurementName?: string);
    /**
     * Sets point's measurement.
     *
     * @param name - measurement name
     * @returns this
     */
    measurement(name: string): Point;
    /**
     * Adds a tag. The caller has to ensure that both name and value are not empty
     * and do not end with backslash.
     *
     * @param name - tag name
     * @param value - tag value
     * @returns this
     */
    tag(name: string, value: string): Point;
    /**
     * Adds a boolean field.
     *
     * @param field - field name
     * @param value - field value
     * @returns this
     */
    booleanField(name: string, value: boolean | any): Point;
    /**
     * Adds an integer field.
     *
     * @param name - field name
     * @param value - field value
     * @returns this
     * @throws NaN or out of int64 range value is supplied
     */
    intField(name: string, value: number | any): Point;
    /**
     * Adds an unsigned integer field.
     *
     * @param name - field name
     * @param value - field value
     * @returns this
     * @throws NaN out of range value is supplied
     */
    uintField(name: string, value: number | any): Point;
    /**
     * Adds a number field.
     *
     * @param name - field name
     * @param value - field value
     * @returns this
     * @throws NaN/Infinity/-Infinity is supplied
     */
    floatField(name: string, value: number | any): Point;
    /**
     * Adds a string field.
     *
     * @param name - field name
     * @param value - field value
     * @returns this
     */
    stringField(name: string, value: string | any): Point;
    /**
     * Sets point timestamp. Timestamp can be specified as a Date (preferred), number, string
     * or an undefined value. An undefined value instructs to assign a local timestamp using
     * the client's clock. An empty string can be used to let the server assign
     * the timestamp. A number value represents time as a count of time units since epoch, the
     * exact time unit then depends on the {@link InfluxDBClient.write | precision} of the API
     * that writes the point.
     *
     * Beware that the current time in nanoseconds can't precisely fit into a JS number,
     * which can hold at most 2^53 integer number. Nanosecond precision numbers are thus supplied as
     * a (base-10) string. An application can also use ES2020 BigInt to represent nanoseconds,
     * BigInt's `toString()` returns the required high-precision string.
     *
     * Note that InfluxDB requires the timestamp to fit into int64 data type.
     *
     * @param value - point time
     * @returns this
     */
    timestamp(value: Date | number | string | undefined): Point;
    /**
     * Creates an InfluxDB protocol line out of this instance.
     * @param settings - settings control serialization of a point timestamp and can also add default tags,
     * nanosecond timestamp precision is used when no `settings` or no `settings.convertTime` is supplied.
     * @returns an InfluxDB protocol line out of this instance
     */
    toLineProtocol(convertTimePrecision?: TimeConverter | WritePrecision): string | undefined;
    toString(): string;
    static fromRecord(record: PointRecord): Point;
}

/** Prevents confusion with the ArrayLike type. Use with PointRecord */
type NotArrayLike<T> = T & {
    length?: string;
};
/** Prevents confusion with the PointRecord type. */
type NotPointRecord<T> = T & {
    measurement?: void;
};
/**
 * The `WritableData` type represents different types of data that can be written.
 * The data can either be a uniform ArrayLike collection or a single value of the following types:
 *
 * - `Point`: Represents a {@link Point} object.
 *
 * - `string`: Represents lines of the [Line Protocol](https://bit.ly/2QL99fu).
 *
 * - `PointRecord`: Represents an anonymous object. Note that a single `PointRecord`
 *   should not have a property of name length, as it could be misinterpreted as ArrayLike.
 *   If unsure, encapsulate your record in an array, i.e. [record].
 */
type WritableData = NotPointRecord<ArrayLike<string> | ArrayLike<Point> | ArrayLike<PointRecord>> | NotArrayLike<PointRecord> | string | Point;
declare const writableDataToLineProtocol: (data: WritableData) => string[];

declare const collectAll: <T>(generator: AsyncGenerator<T, any, any>) => Promise<T[]>;

/**
 * `InfluxDBClient` for interacting with an InfluxDB server, simplifying common operations such as writing, querying.
 */
declare class InfluxDBClient {
    private readonly _options;
    private readonly _writeApi;
    private readonly _queryApi;
    /**
     * Creates a new instance of the `InfluxDBClient` for interacting with an InfluxDB server, simplifying common operations such as writing, querying.
     * @param options - client options
     */
    constructor(options: ClientOptions);
    private _mergeWriteOptions;
    write(data: WritableData, database?: string, org?: string, writeOptions?: Partial<WriteOptions>): Promise<void>;
    query(query: string, database?: string, queryType?: QueryType): AsyncGenerator<Record<string, any>, void, void>;
    close(): Promise<void>;
}

export { AbortError, Cancellable, ChunkCombiner, ClientOptions, CommunicationObserver, ConnectionOptions, DEFAULT_ConnectionOptions, DEFAULT_WriteOptions, HttpHeaders as Headers, HttpError, HttpHeaders, IllegalArgumentError, InfluxDBClient, Log, Logger, NotArrayLike, NotPointRecord, Point, PointRecord, QueryType, RequestTimedOutError, ResponseStartedFn, SendOptions, TimeConverter, Transport, WritableData, WriteOptions, WritePrecision, collectAll, consoleLogger, convertTime, convertTimeToNanos, createTextDecoderCombiner, currentTime, dateToProtocolTimestamp, escape, setLogger, useProcessHrtime, writableDataToLineProtocol };
